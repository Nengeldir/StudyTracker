<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Premium Mindmap Visualizer</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400&display=swap"
        rel="stylesheet">

    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- MathJax -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            --bg-color: #0f1115;
            --sidebar-bg: rgba(22, 24, 29, 0.85);
            --sidebar-border: rgba(255, 255, 255, 0.08);
            --text-primary: #e6e6e6;
            --text-secondary: #a0a0a0;
            --accent-color: #646cff;
            --node-bg: rgba(30, 32, 38, 0.95);
            --node-border: rgba(100, 108, 255, 0.3);
            --link-color: #444;
            --font-main: 'Inter', sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: var(--font-main);
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        #sidebar {
            width: 350px;
            display: flex;
            flex-direction: column;
            background: var(--sidebar-bg);
            border-right: 1px solid var(--sidebar-border);
            backdrop-filter: blur(12px);
            z-index: 10;
            transition: transform 0.3s ease;
            position: relative;
        }

        #sidebar.collapsed {
            transform: translateX(-100%);
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--sidebar-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-header h2 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .btn {
            background: var(--accent-color);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-family: var(--font-main);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
        }

        .btn-outline:hover {
            background: rgba(100, 108, 255, 0.1);
        }

        textarea {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            padding: 20px;
            font-family: var(--font-mono);
            font-size: 13px;
            resize: none;
            outline: none;
            line-height: 1.5;
        }

        textarea::-webkit-scrollbar {
            width: 8px;
        }

        textarea::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        /* Toggle Button */
        #toggle-sidebar {
            position: absolute;
            left: 20px;
            top: 20px;
            z-index: 100;
            background: var(--node-bg);
            border: 1px solid var(--sidebar-border);
            color: var(--text-primary);
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        #toggle-sidebar:hover {
            border-color: var(--accent-color);
        }

        /* Controls */
        .controls-area {
            padding: 15px;
            border-bottom: 1px solid var(--sidebar-border);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-row {
            display: flex;
            gap: 10px;
        }

        #search-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--sidebar-border);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            font-family: var(--font-main);
            outline: none;
        }

        #search-input:focus {
            border-color: var(--accent-color);
        }

        .file-upload-label {
            display: inline-block;
            cursor: pointer;
        }

        .highlighted-node rect {
            stroke: #ffeb3b !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 8px rgba(255, 235, 59, 0.5));
        }

        /* Main Canvas */
        #viz-container {
            flex: 1;
            position: relative;
            cursor: grab;
            overflow: hidden;
        }

        #viz-container:active {
            cursor: grabbing;
        }

        /* SVG Styles */
        .node foreignObject {
            overflow: visible;
        }

        .node-content {
            background: var(--node-bg);
            border: 1px solid var(--node-border);
            padding: 10px 16px;
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            min-width: 150px;
            max-width: 400px;
            display: inline-block;
            /* Prevent selecting text while dragging */
            user-select: none;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .node-content:hover {
            border-color: var(--accent-color);
        }

        .node-content h3 {
            margin: 0 0 4px 0;
            font-size: 15px;
            color: #fff;
        }

        .node-content p {
            margin: 0;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .link {
            fill: none;
            stroke: var(--link-color);
            stroke-width: 1.5px;
            transition: opacity 0.5s;
        }

        /* MathJax Adjustments */
        mjx-container {
            font-size: 110% !important;
            color: #d0d0ff !important;
        }
    </style>
</head>

<body>

    <div id="toggle-sidebar" onclick="toggleSidebar()">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="9" y1="3" x2="9" y2="21"></line>
        </svg>
    </div>

    <div id="sidebar">
        <div class="sidebar-header">
            <h2>Mindmap</h2>
            <div style="display: flex; gap: 5px;">
                <button class="btn btn-outline" onclick="saveNotes()" title="Save to file">ðŸ’¾</button>
                <button class="btn" onclick="render()">Update Map</button>
            </div>
        </div>
        <div class="controls-area">
            <div class="control-row">
                <input type="text" id="search-input" placeholder="Search topic..."
                    onkeydown="if(event.key==='Enter') searchTopic()">
                <button class="btn" onclick="searchTopic()">Go</button>
            </div>
        </div>
        <textarea id="input-text" spellcheck="false" placeholder="Loading notes..."></textarea>
    </div>

    <div id="viz-container"></div>

    <script>
        // ---- PARSER ----
        function parseMarkdown(text) {
            if (!text) return { name: "Root", children: [] };
            const lines = text.split('\n');
            const root = { name: "Root", children: [] };
            const stack = [{ node: root, level: -1 }]; // Level -1 for root

            // Helper to get depth of * indentation
            function getBulletLevel(line) {
                const match = line.match(/^(\s*)\*/);
                return match ? match[1].length + 1 : 0; // +1 to distinguish from headers
            }

            lines.forEach(line => {
                line = line.trimEnd();
                if (!line) return;

                let content = "";
                let level = 0;
                let isHeader = false;

                if (line.startsWith('###')) {
                    isHeader = true;
                    level = 0; // Headers are top level children of Root
                    content = line.replace(/^#+\s*/, '');
                } else if (line.trim().startsWith('*')) {
                    const leadingSpaces = line.match(/^\s*/)[0].length;
                    level = Math.floor(leadingSpaces / 2) + 1; // logical depth
                    content = line.trim().replace(/^\*\s*/, '');
                } else {
                    return; // Skip other lines
                }

                const htmlContent = parseRichText(content);
                const newNode = { name: htmlContent, children: [] };

                // Find parent
                while (stack.length > 0 && stack[stack.length - 1].level >= level) {
                    stack.pop();
                }

                const parent = stack[stack.length - 1].node;
                parent.children.push(newNode);
                stack.push({ node: newNode, level: level });
            });

            return root;
        }

        function parseRichText(text) {
            let html = text.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');
            return html;
        }

        // ---- VISUALIZER ----
        let svg, g, zoom;
        let rootData, treeLayout;
        let i = 0;
        const duration = 750;

        function initViz() {
            const container = document.getElementById('viz-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            svg = d3.select("#viz-container").append("svg")
                .attr("width", width)
                .attr("height", height)
                .on("dblclick.zoom", null);

            g = svg.append("g")
                .attr("transform", "translate(100,0)");

            zoom = d3.zoom().on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

            svg.call(zoom)
                .call(zoom.transform, d3.zoomIdentity.translate(150, height / 2).scale(0.8));

            window.addEventListener('resize', () => {
                svg.attr("width", container.clientWidth).attr("height", container.clientHeight);
            });
        }

        // ---- STATE ----
        let rootHierarchy;

        function update(source) {
            if (!rootHierarchy) return;

            const treeRoot = rootHierarchy;

            let expandedCount = 0;
            treeRoot.each(d => expandedCount++);

            const nodeHeight = 80;
            const treeHeight = Math.max(800, expandedCount * nodeHeight);

            const tree = d3.tree().nodeSize([nodeHeight, 400]);

            tree(treeRoot);

            const nodes = treeRoot.descendants();
            const links = treeRoot.links();

            nodes.forEach(d => { d.y = d.depth * 400; });

            // Nodes
            const node = g.selectAll('g.node')
                .data(nodes, d => d.id || (d.id = ++i));

            const nodeEnter = node.enter().append('g')
                .attr('class', 'node')
                .attr("transform", d => `translate(${source.y0 || 0},${source.x0 || 0})`)
                .on('click', click);

            const fo = nodeEnter.append('foreignObject')
                .attr("width", 380)
                .attr("height", 200)
                .attr("x", -20)
                .attr("y", -30);

            const div = fo.append('xhtml:div')
                .attr('class', 'node-content')
                .html(d => `<div class="inner">${d.data.name}</div>`);

            const nodeUpdate = node.merge(nodeEnter).transition()
                .duration(duration)
                .attr("transform", d => `translate(${d.y},${d.x})`);

            nodeUpdate.select('.node-content').style('border-left', d => {
                return d._children ? "3px solid var(--accent-color)" : "1px solid var(--node-border)";
            }).style('cursor', d => (d.children || d._children) ? "pointer" : "default");

            const nodeExit = node.exit().transition()
                .duration(duration)
                .attr("transform", d => `translate(${source.y},${source.x})`)
                .remove();

            nodeExit.select('foreignObject').style('opacity', 0);

            // Links
            const link = g.selectAll('path.link')
                .data(links, d => d.target.id);

            const linkEnter = link.enter().insert('path', "g")
                .attr("class", "link")
                .attr('d', d => {
                    const o = { x: source.x0 || 0, y: source.y0 || 0 };
                    return diagonal(o, o);
                });

            link.merge(linkEnter).transition()
                .duration(duration)
                .attr('d', d => diagonal(d.source, d.target));

            link.exit().transition()
                .duration(duration)
                .attr('d', d => {
                    const o = { x: source.x, y: source.y };
                    return diagonal(o, o);
                })
                .remove();

            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            if (window.MathJax) {
                MathJax.typesetPromise();
            }
        }

        function diagonal(s, d) {
            return `M ${s.y} ${s.x}
                    C ${(s.y + d.y) / 2} ${s.x},
                      ${(s.y + d.y) / 2} ${d.x},
                      ${d.y} ${d.x}`;
        }

        function click(event, d) {
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            update(d);
        }

        function collapse(d) {
            if (d.children) {
                d._children = d.children;
                d._children.forEach(collapse);
                d.children = null;
            }
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
        }

        function render() {
            const text = document.getElementById('input-text').value;
            const data = parseMarkdown(text);

            rootHierarchy = d3.hierarchy(data, d => d.children);
            rootHierarchy.x0 = 0;
            rootHierarchy.y0 = 0;

            update(rootHierarchy);
        }

        // ---- API INTEGRATION ----

        async function loadNotes() {
            try {
                const response = await fetch('/api/notes');
                if (!response.ok) throw new Error("Failed to fetch notes");
                const data = await response.json();
                document.getElementById('input-text').value = data.content || "";
                render();
            } catch (e) {
                console.error("Error loading notes:", e);
                alert("Error loading notes: " + e.message);
            }
        }

        async function saveNotes() {
            const content = document.getElementById('input-text').value;
            try {
                const response = await fetch('/api/notes', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ content: content })
                });
                if (!response.ok) throw new Error("Failed to save notes");

                // Visual feedback
                const btn = document.querySelector('button[title="Save to file"]');
                const originalText = btn.innerHTML;
                btn.innerHTML = "âœ…";
                setTimeout(() => btn.innerHTML = originalText, 1500);

            } catch (e) {
                console.error("Error saving notes:", e);
                alert("Error saving notes: " + e.message);
            }
        }

        // ---- SEARCH ----
        let lastQuery = "";
        let searchMatches = [];
        let currentMatchIndex = 0;

        function searchTopic() {
            const query = document.getElementById('search-input').value.toLowerCase();
            if (!query) return;

            if (query !== lastQuery) {
                lastQuery = query;
                searchMatches = [];
                currentMatchIndex = 0;

                function collectMatches(d) {
                    const text = d.data.name.replace(/<[^>]*>/g, '').toLowerCase();
                    if (text.includes(query)) {
                        searchMatches.push(d);
                    }
                    const children = d.children || d._children;
                    if (children) {
                        children.forEach(collectMatches);
                    }
                }

                if (rootHierarchy) {
                    collectMatches(rootHierarchy);
                }

                if (searchMatches.length === 0) {
                    alert("Topic not found");
                    return;
                }
            } else {
                currentMatchIndex = (currentMatchIndex + 1) % searchMatches.length;
            }

            const foundNode = searchMatches[currentMatchIndex];

            if (searchMatches.length > 1) {
                console.log(`Showing match ${currentMatchIndex + 1} of ${searchMatches.length}`);
                document.getElementById('search-input').setAttribute('title', `Match ${currentMatchIndex + 1} of ${searchMatches.length}`);
            }

            if (foundNode) {
                let current = foundNode;
                while (current.parent) {
                    const p = current.parent;
                    if (p._children) {
                        p.children = p._children;
                        p._children = null;
                    }
                    current = p;
                }

                update(rootHierarchy);

                const width = document.getElementById('viz-container').clientWidth;
                const height = document.getElementById('viz-container').clientHeight;

                const t = d3.zoomIdentity
                    .translate(width / 2, height / 2)
                    .scale(1)
                    .translate(-foundNode.y, -foundNode.x);

                svg.transition().duration(750).call(zoom.transform, t);

                d3.selectAll('.node-content').style('border-color', null).style('box-shadow', null);

                g.selectAll('.node')
                    .filter(d => d === foundNode)
                    .select('.node-content')
                    .style('border-color', '#ffeb3b')
                    .style('box-shadow', '0 0 20px rgba(255, 235, 59, 0.6)')
                    .transition().duration(2500)
                    .style('border-color', 'var(--node-border)')
                    .style('box-shadow', '0 4px 12px rgba(0,0,0,0.2)');
            }
        }

        // Init
        window.addEventListener('DOMContentLoaded', () => {
            initViz();
            loadNotes();
        });
    </script>
</body>

</html>